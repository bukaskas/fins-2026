generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum LessonType {
  PRIVATE
  GROUP
  EXTRA_PRIVATE
  EXTRA_GROUP
  FOIL
  KIDS
}

enum LessonBookingStatus {
  RESERVED
  CONFIRMED
  COMPLETED
  NO_SHOW
  CANCELED
}

enum BeachUseType {
  REGULAR
  LOCAL
  MEMBER_FREE
}

enum BeachVisitStatus {
  OPEN
  COMPLETED
  CANCELED
}

enum InventoryCategory {
  KITE
  BOARD
  HARNESS
  BAR
  WETSUIT
  ACCESSORY
  OTHER
}

enum ItemCondition {
  NEW
  GOOD
  FAIR
  DAMAGED
  RETIRED
}

enum RentalStatus {
  OPEN
  RETURNED
  LATE
  CANCELED
}

enum InventoryMovementType {
  IN
  OUT
  ADJUSTMENT
  MAINTENANCE
  LOST
}

model Booking {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name       String
  date       DateTime
  email      String
  phone      String
  service    String
  createdAt  DateTime @default(now()) @db.Timestamp(6)
  instructor String?
  time       String?
}

enum Role {
  ADMIN
  MEMBER
  STAFF
  ACCOUNTANT
  INSTRUCTOR
  KITER
  OWNER
}

model User {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email         String    @unique
  password      String
  name          String?
  phone         String?
  image         String?
  emailVerified DateTime?
  createdAt     DateTime  @default(now()) @db.Timestamp(6)
  updatedAt     DateTime  @default(now()) @updatedAt

  role     Role      @default(KITER)
  accounts Account[]
  sessions Session[]
  members  Member[]
  orders   Order[]
  payments Payment[]

  lessonSessionsAsInstructor LessonSession[]     @relation("LessonInstructor")
  lessonBookings             LessonBooking[]
  beachVisits                BeachVisit[]
  rentals                    Rental[]
  inventoryMovements         InventoryMovement[]
  wallets                    UserWallet[]
  walletLedgerOwned          WalletLedger[]      @relation("WalletOwner")
  walletLedgerActor          WalletLedger[]      @relation("WalletActor")
}

model Account {
  id                String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionToken String   @unique
  userId       String   @db.Uuid
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}

model Member {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId         String   @db.Uuid
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  validUntil     DateTime @db.Timestamp(6)
  membershipType String
  createdAt      DateTime @default(now()) @db.Timestamp(6)
}

enum ProductType {
  SERVICE
  BUNDLE_CREDIT
}

enum WalletType {
  BEACH_USE
  LESSON_HOURS
}

enum WalletUnit {
  ENTRY
  HOUR
}

enum WalletLedgerReason {
  PURCHASE
  CONSUMPTION
  ADJUSTMENT
  REFUND
  EXPIRY
  MIGRATION
}

model Product {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name            String
  sku             String      @unique
  type            ProductType
  priceCents      Int // always store money in cents
  currency        String      @default("EGP")
  creditUnits     Int? // e.g. 10 or 20 for bundle products
  creditValidDays Int? // optional expiry window
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now()) @db.Timestamp(6)

  orderLines OrderLine[]
}

// When selling prepaid credits (bundle/hours):

// Create Order + OrderLine
// Post a WalletLedger entry with:
// positive delta (credit)
// reason = PURCHASE
// orderId and orderLineId filled
// So: OrderLine tells you what was sold, 
// WalletLedger tells you how balance changed over time.
model Order {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId     String   @db.Uuid
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  status     String   @default("OPEN") // OPEN, PAID, PARTIAL, CANCELED
  totalCents Int
  createdAt  DateTime @default(now()) @db.Timestamp(6)

  lines         OrderLine[]
  allocations   PaymentAllocation[]
  walletEntries WalletLedger[]
}

model OrderLine {
  id             String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orderId        String  @db.Uuid
  order          Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId      String  @db.Uuid
  product        Product @relation(fields: [productId], references: [id])
  qty            Int     @default(1)
  unitPriceCents Int
  lineTotalCents Int

  // snapshot for bundles at time of sale
  creditUnitsEach Int?
  walletEntries   WalletLedger[]
}

model Payment {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @db.Uuid
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amountCents Int
  method      String // CASH, CARD, TRANSFER...
  reference   String?
  receivedAt  DateTime @default(now()) @db.Timestamp(6)

  allocations   PaymentAllocation[]
  walletEntries WalletLedger[]
}

model PaymentAllocation {
  id          String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paymentId   String  @db.Uuid
  payment     Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  orderId     String  @db.Uuid
  order       Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  amountCents Int

  @@unique([paymentId, orderId])
}

model UserWallet {
  id        String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String     @db.Uuid
  type      WalletType
  unit      WalletUnit
  balance   Decimal    @default(0) @db.Decimal(12, 2)
  createdAt DateTime   @default(now()) @db.Timestamp(6)
  updatedAt DateTime   @default(now()) @updatedAt

  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  entries WalletLedger[]

  @@unique([userId, type])
  @@index([type])
}

model WalletLedger {
  id             String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  walletId       String             @db.Uuid
  userId         String             @db.Uuid
  actorId        String?            @db.Uuid
  delta          Decimal            @db.Decimal(12, 2)
  balanceAfter   Decimal            @db.Decimal(12, 2)
  reason         WalletLedgerReason
  note           String?
  idempotencyKey String?
  occurredAt     DateTime           @default(now()) @db.Timestamp(6)

  orderId         String? @db.Uuid
  orderLineId     String? @db.Uuid
  paymentId       String? @db.Uuid
  lessonBookingId String? @db.Uuid
  beachVisitId    String? @db.Uuid
  rentalId        String? @db.Uuid

  wallet        UserWallet     @relation(fields: [walletId], references: [id], onDelete: Cascade)
  owner         User           @relation("WalletOwner", fields: [userId], references: [id], onDelete: Cascade)
  actor         User?          @relation("WalletActor", fields: [actorId], references: [id], onDelete: SetNull)
  order         Order?         @relation(fields: [orderId], references: [id], onDelete: SetNull)
  orderLine     OrderLine?     @relation(fields: [orderLineId], references: [id], onDelete: SetNull)
  payment       Payment?       @relation(fields: [paymentId], references: [id], onDelete: SetNull)
  lessonBooking LessonBooking? @relation(fields: [lessonBookingId], references: [id], onDelete: SetNull)
  beachVisit    BeachVisit?    @relation(fields: [beachVisitId], references: [id], onDelete: SetNull)
  rental        Rental?        @relation(fields: [rentalId], references: [id], onDelete: SetNull)

  @@unique([walletId, idempotencyKey])
  @@index([walletId, occurredAt])
  @@index([userId, occurredAt])
  @@index([reason, occurredAt])
}

model LessonSession {
  id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  startsAt     DateTime   @db.Timestamp(6)
  endsAt       DateTime   @db.Timestamp(6)
  lessonType   LessonType
  capacity     Int        @default(1)
  instructorId String?    @db.Uuid
  notes        String?
  createdAt    DateTime   @default(now()) @db.Timestamp(6)
  updatedAt    DateTime   @default(now()) @updatedAt

  instructor User?           @relation("LessonInstructor", fields: [instructorId], references: [id], onDelete: SetNull)
  bookings   LessonBooking[]

  @@index([startsAt])
  @@index([instructorId, startsAt])
}

model LessonBooking {
  id          String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId   String              @db.Uuid
  guestId     String              @db.Uuid
  status      LessonBookingStatus @default(RESERVED)
  attended    Boolean             @default(false)
  checkedInAt DateTime?           @db.Timestamp(6)
  notes       String?
  createdAt   DateTime            @default(now()) @db.Timestamp(6)

  session       LessonSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  guest         User           @relation(fields: [guestId], references: [id], onDelete: Cascade)
  walletEntries WalletLedger[]

  @@unique([sessionId, guestId])
  @@index([guestId, createdAt])
}

model BeachVisit {
  id           String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  guestId      String           @db.Uuid
  visitDate    DateTime         @db.Date
  type         BeachUseType
  status       BeachVisitStatus @default(OPEN)
  checkedInAt  DateTime?        @db.Timestamp(6)
  checkedOutAt DateTime?        @db.Timestamp(6)
  notes        String?
  createdAt    DateTime         @default(now()) @db.Timestamp(6)

  guest         User           @relation(fields: [guestId], references: [id], onDelete: Cascade)
  walletEntries WalletLedger[]

  @@index([guestId, visitDate])
}

model Rental {
  id         String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  guestId    String       @db.Uuid
  startsAt   DateTime     @db.Timestamp(6)
  dueAt      DateTime     @db.Timestamp(6)
  returnedAt DateTime?    @db.Timestamp(6)
  status     RentalStatus @default(OPEN)
  totalCents Int          @default(0)
  notes      String?
  createdAt  DateTime     @default(now()) @db.Timestamp(6)
  updatedAt  DateTime     @default(now()) @updatedAt

  guest         User           @relation(fields: [guestId], references: [id], onDelete: Cascade)
  lines         RentalLine[]
  walletEntries WalletLedger[]

  @@index([guestId, startsAt])
  @@index([status, dueAt])
}

model RentalLine {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  rentalId        String   @db.Uuid
  inventoryItemId String   @db.Uuid
  qty             Int      @default(1)
  unitPriceCents  Int
  lineTotalCents  Int
  createdAt       DateTime @default(now()) @db.Timestamp(6)

  rental        Rental              @relation(fields: [rentalId], references: [id], onDelete: Cascade)
  inventoryItem InventoryItem       @relation(fields: [inventoryItemId], references: [id], onDelete: Restrict)
  movements     InventoryMovement[]

  @@index([rentalId])
  @@index([inventoryItemId])
}

model InventoryItem {
  id           String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sku          String            @unique
  name         String
  category     InventoryCategory
  size         String?
  totalQty     Int               @default(0)
  availableQty Int               @default(0)
  condition    ItemCondition     @default(GOOD)
  isActive     Boolean           @default(true)
  createdAt    DateTime          @default(now()) @db.Timestamp(6)
  updatedAt    DateTime          @default(now()) @updatedAt

  rentalLines RentalLine[]
  movements   InventoryMovement[]

  @@index([category, isActive])
}

model InventoryMovement {
  id              String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  inventoryItemId String                @db.Uuid
  rentalLineId    String?               @db.Uuid
  actorId         String?               @db.Uuid
  type            InventoryMovementType
  qty             Int
  reason          String?
  createdAt       DateTime              @default(now()) @db.Timestamp(6)

  inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  rentalLine    RentalLine?   @relation(fields: [rentalLineId], references: [id], onDelete: SetNull)
  actor         User?         @relation(fields: [actorId], references: [id], onDelete: SetNull)

  @@index([inventoryItemId, createdAt])
  @@index([type, createdAt])
}
